# CSS 高级面试题

在 CSS 高级面试中，面试官可能会提出一系列深入且具体的问题，以评估应聘者的专业知识、实践经验和解决问题的能力。以下是一些可能的高级 CSS 面试题及其简要答案：

## 1. 解释一下 CSS 的盒子模型，并比较标准盒子模型与 IE 盒子模型的区别。

**答案**：

- **标准盒子模型**：元素的宽度和高度仅包括内容区域（content），不包括边框（border）、内边距（padding）和外边距（margin）。因此，整个元素的宽度 = 内容的宽度 + 边框 + 内边距 + 外边距。
- **IE 盒子模型**（也称为怪异模式）：元素的宽度和高度包括内容区域、边框和内边距，但不包括外边距。因此，整个元素的宽度 = 内容的宽度（包括边框和内边距） + 外边距。

CSS3 引入了`box-sizing`属性，允许开发者在`content-box`（标准盒子模型）和`border-box`（IE 盒子模型）之间进行选择。

## 2. CSS 选择器有哪些？并解释优先级是如何计算的。

**答案**：

- **选择器类型**：

  - id 选择器（#id）
  - 类选择器（.class）
  - 标签选择器（element）
  - 相邻选择器（A + B）
  - 子选择器（A > B）
  - 后代选择器（A B）
  - 通配符选择器（\*）
  - 属性选择器（[attribute=value]）
  - 伪类选择器（:hover, :first-child 等）
  - 伪元素选择器（::before, ::after 等）

- **优先级计算**：
  - `!important` 声明的样式优先级最高。
  - 内联样式（在 HTML 元素内部使用`style`属性）次之。
  - ID 选择器优先级高于类选择器。
  - 类选择器优先级高于标签选择器。
  - 如果优先级相同，则最后出现的样式会被应用。
  - 继承得到的样式的优先级最低。

## 3. CSS3 引入了哪些新特性？请列举并简要说明。

**答案**：

- **圆角边框（border-radius）**：允许为元素创建圆角边框。
- **阴影效果（text-shadow, box-shadow）**：为文本和元素添加阴影效果。
- **渐变（gradients）**：允许创建颜色渐变效果作为背景图像。
- **过渡（transitions）**：允许 CSS 属性在值的变化时有一定的过渡效果。
- **动画（animations）**：通过`@keyframes`规则创建复杂的动画效果。
- **媒体查询（Media Queries）**：允许根据不同的媒体类型和条件应用不同的样式规则，主要用于响应式设计。
- **多列布局（multi-column layout）**：允许将文本或内容分成多列显示。
- **弹性盒布局（Flexbox）**：提供了一种更加灵活的方式来对容器中的项目进行布局、对齐和分配空间。

## 4. 请解释一下 CSS3 中的 Flexbox 布局模型，并说明其适用场景。

**答案**：

Flexbox 布局模型旨在提供一种更加高效的方式来对容器中的项目进行布局、对齐和分配空间。它不同于传统的块级布局（block layout）和内联布局（inline layout），Flexbox 布局更加灵活，可以自动调整子元素的大小以填充可用空间，或者根据子元素的大小自动调整容器的大小。

**适用场景**：

- 复杂布局的设计，如垂直居中、水平居中、多栏布局等。
- 响应式设计，Flexbox 可以很容易地适应不同屏幕尺寸和设备。
- 组件化开发，Flexbox 的布局方式非常适合前端组件化开发的需求。

## 5. 如何使用 CSS3 实现一个元素的旋转动画，并解释`transform-origin`的作用。

**答案**：

要实现一个元素的旋转动画，可以使用`@keyframes`规则定义动画的关键帧，并使用`animation`属性将动画应用于元素。例如：

```css
@keyframes rotateAnimation {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.element {
  animation: rotateAnimation 2s linear infinite;
}
```

`transform-origin`属性用于设置元素进行变形（如旋转、缩放等）时的基点（即变形的中心点）。默认情况下，变形是相对于元素的中心点进行的。通过设置`transform-origin`，可以改变这个基点的位置，从而影响变形的效果。例如：

```css
.element {
  transform: rotate(45deg);
  transform-origin: top left; /* 将旋转基点设置为元素的左上角 */
}
```

## 6. 解释一下 CSS3 中的动画关键帧(@keyframes)和它们是如何工作的？

**解答**：
CSS3 中的动画关键帧(@keyframes)是一个强大的特性，它允许开发者创建复杂的动画效果。通过定义一组关键帧，可以控制元素在动画过程中的不同状态。使用@keyframes 规则来定义一个动画的多个关键帧，每个关键帧表示动画中某个时间点的样式。关键帧可以通过百分比或关键词（如 from 和 to）来指定。

```css
/* 定义一个名为 'fade' 的动画 */
@keyframes fade {
  0% {
    opacity: 0;
  } /* 动画开始时，元素完全透明 */
  50% {
    opacity: 0.5;
  } /* 动画进行到一半时，元素半透明 */
  100% {
    opacity: 1;
  } /* 动画结束时，元素完全不透明 */
}
```

创建了关键帧之后，需要将动画应用于相应的元素。这通常使用`animation`属性完成，该属性接受多个子属性，包括动画名称、持续时间、速度曲线、延迟时间、播放次数、播放方向和动画结束后元素的状态等。

## 7. 如何在 CSS3 中实现一个复杂的动画序列，包括延迟、迭代和反向播放？

**解答**：
在 CSS3 中实现一个包含延迟、迭代和反向播放的复杂动画序列，可以通过结合使用@keyframes 规则和 animation 属性来完成。

首先，使用@keyframes 规则定义动画的关键帧。然后，通过 animation 属性设置动画的持续时间、延迟时间、迭代次数、播放方向等。

```css
/* 定义一个名为 'complex-animation' 的动画 */
@keyframes complex-animation {
  0% {
    transform: translateY(0);
  } /* 动画开始时元素位于顶部 */
  25% {
    transform: translateY(50px);
  } /* 在动画的四分之一处向下移动50像素 */
  50% {
    transform: translateY(100px);
  } /* 在动画的一半处向下移动100像素 */
  75% {
    transform: translateY(50px);
  } /* 在动画的四分之三处向上移动50像素 */
  100% {
    transform: translateY(0);
  } /* 动画结束时返回到顶部 */
}

/* 应用动画到元素 */
div {
  width: 100px;
  height: 100px;
  background-color: red;
  animation: complex-animation 4s ease-in-out 2s 3 alternate;
}
```

在这个例子中，`animation`属性设置了动画名称为`complex-animation`，持续时间为 4 秒，采用`ease-in-out`速度曲线，延迟 2 秒后开始播放，播放 3 次，并且每次播放都以相反的方向（`alternate`）进行。

## 8. CSS3 中的变形原点(transform-origin)是什么？它有哪些应用场景？

**解答**：

CSS3 中的变形原点(transform-origin)是一个属性，它允许开发者控制元素在应用变形（如旋转、缩放或位移）时的参考点。默认情况下，变形是相对于元素的中心进行的，但通过设置 transform-origin，可以将变形的参考点更改到其他位置。

transform-origin 接受一个或两个值，用于指定 X 轴和 Y 轴上的偏移量。这些值可以是百分比、像素、em 单位或其他长度单位，也可以是关键字 left、center 和 right 以及 top、center 和 bottom。

**应用场景**：

- **旋转动画**：通过改变 transform-origin，可以控制旋转的中心点，从而创建出更加复杂和动态的旋转效果。
- **缩放效果**：在需要对元素的某个特定区域进行缩放时，可以使用 transform-origin 来指定缩放的中心点。
- **位移动画**：在位移动画中，transform-origin 决定了元素从哪里开始移动。
- **3D 转换**：在 3D 转换中，transform-origin 同样重要，因为它可以影响元素在三维空间中的旋转和移动。
- **SVG 图形处理**：在处理 SVG 图形时，transform-origin 可以帮助更好地定位和调整形状的变换中心。

## 9. CSS 选择器有哪些高级用法？

**解答**：
CSS 选择器除了基本的 id 选择器、类选择器、标签选择器外，还有许多高级用法，如：

- **属性选择器**：可以根据元素的属性及其值来选择元素，例如`[type="text"]`。
- **伪类选择器**：用于定义元素的特殊状态，如`:hover`、`:active`、`:first-child`等。CSS3 还引入了更多的伪类选择器，如`:nth-child()`、`:nth-of-type()`等。
- **伪元素选择器**：伪元素用于选择元素的特定部分，例如`::before`和`::after`，它们可以在元素的内容前后插入新的内容或样式。CSS3 还引入了更多的伪元素，如`::first-letter`、`::first-line`等。
- **后代选择器**：通过空格分隔的选择器，用于选择某个元素内部的后代元素，例如`div p`会选中所有位于`div`元素内部的`p`元素。
- **子选择器**：使用`>`符号表示的直接子元素选择器，例如`ul > li`会选中所有直接位于`ul`元素下的`li`元素，而不会选中更深层次的嵌套`li`元素。
- **相邻同胞选择器**：使用`+`符号，用于选择紧接在另一元素后的元素，且二者有相同的父元素。例如，`h1 + p`会选择紧接在`h1`元素后且在同一父元素下的`p`元素。
- **通用同胞选择器**：使用`~`符号，用于选择某个元素之后的所有同胞元素（即具有相同父元素的元素）。例如，`h1 ~ p`会选择所有在`h1`元素之后的所有`p`同胞元素。
- **群组选择器**：通过逗号分隔的选择器列表，可以对多个元素应用相同的样式规则，例如`h1, h2, h3 { color: blue; }`会将所有`h1`、`h2`和`h3`元素的文字颜色设置为蓝色。

## 10. CSS 中的层叠上下文(Stacking Contexts)是什么？它如何影响元素的堆叠顺序？

**解答**：
CSS 中的层叠上下文（Stacking Contexts）是 HTML 文档中元素的一种堆叠方式。当元素的堆叠顺序发生冲突时，浏览器会根据层叠上下文来决定元素的最终显示顺序。每个层叠上下文都有一个自己的堆叠顺序，这个顺序决定了该上下文内部所有元素的堆叠顺序。

层叠上下文可以由以下 CSS 属性之一创建：

- 文档的根元素（`<html>`）
- 定位元素（即其 position 属性不是 static 的元素）
- 元素的 z-index 值不是 auto 的 flex 容器（flex items 不创建新的堆叠上下文）
- 元素的 z-index 值不是 auto 的 grid 容器（grid items 不创建新的堆叠上下文）
- 元素的 opacity 值小于 1
- 元素的 transform 值不是 none
- 元素的 mix-blend-mode 值不是 normal
- 元素的 filter 值不是 none
- 元素的 isolation 属性是 isolate
- 在 will-change 中指定了任意 CSS 属性，即便实际上没有变化
- 在-webkit-overflow-scrolling 属性上设置了 touch

层叠顺序按照以下规则进行：

1. 背景和边框
2. 负 z-index
3. 块级盒的堆叠上下文
4. 浮动盒
5. 内联盒（包括内联块、表格单元格和表格标题）
6. 非定位的后代盒
7. 正 z-index
8. 堆叠上下文的层叠顺序由子元素的 z-index 决定

## 11. 如何使用 CSS Flexbox 布局实现复杂的页面布局？

**解答**：
Flexbox 布局（Flexible Box Layout）是一种 CSS 布局模式，提供了一种更有效的方式来布局、对齐和分配容器中项目的空间，即使它们的大小未知或是动态变化的。

要实现复杂的页面布局，可以按照以下步骤使用 Flexbox：

1. **定义 Flex 容器**：首先，需要为父元素设置`display: flex;`或`display: inline-flex;`来将其定义为一个 Flex 容器。

2. **调整主轴和交叉轴**：Flex 容器有两个轴：主轴（main axis）和交叉轴（cross axis）。通过`flex-direction`属性可以调整主轴的方向（默认为 row，即水平方向）。

3. **分配空间**：使用`justify-content`和`align-items`属性分别控制项目在主轴和交叉轴上的对齐方式和空间分配。

4. **调整项目大小**：每个 Flex 项目（Flex 容器的子元素）的大小可以通过`flex-grow`、`flex-shrink`和`flex-basis`属性进行调整。其中，`flex-grow`定义了项目的放大比例，`flex-shrink`定义了项目的缩小比例，`flex-basis`定义了项目在分配多余空间之前的默认大小。

5. **处理多行布局**：如果 Flex 容器中的项目需要换行显示，可以通过`flex-wrap`属性来控制。`nowrap`（默认值）表示不换行，`wrap`表示换行，`wrap-reverse`表示反向换行。

6. **对齐多行内容**：当 Flex 容器中的项目换行时，可以使用`align-content`**属性**来对齐这些行在交叉轴上的位置。`align-content`属性类似于`align-items`，但它应用于多行的情况，控制的是行与行之间的间距和对齐方式。

## 12. CSS Grid 布局与 Flexbox 布局相比有哪些主要的不同点和优势？

**解答**：

**主要不同点**：

1. **维度差异**：Flexbox 主要用于一维布局，即它主要用于处理行内或列内项目的对齐、分布和大小调整。而 CSS Grid 布局是二维的，它可以同时处理行和列，非常适合复杂的页面布局。

2. **项目定位**：在 Flexbox 中，项目（flex items）是沿着主轴排列的，并且它们只能沿着主轴或交叉轴进行简单的对齐和分布。而在 Grid 布局中，项目（grid items）可以放置在由网格线定义的明确区域（grid areas）内，提供了更高的布局控制力。

3. **网格线**：Grid 布局引入了网格线的概念，允许你使用网格线号码（line numbers）来精确定位元素。Flexbox 没有类似的直接定位机制。

4. **容器属性**：Grid 布局提供了更多的容器属性（如 `grid-template-columns`、`grid-template-rows`、`grid-template-areas` 等），用于定义网格的结构。而 Flexbox 的容器属性则更侧重于项目的对齐和分布。

**优势**：

1. **更强大的布局能力**：Grid 布局能够处理更加复杂和灵活的布局需求，包括响应式设计、多列布局、复杂组件布局等。

2. **更高的可维护性**：通过使用网格区域（grid areas）和网格线，Grid 布局使得布局代码更加直观和易于维护。

3. **更好的浏览器支持**：现代浏览器对 Grid 布局的支持已经非常广泛，并且随着 Web 开发的不断发展，Grid 布局正逐渐成为实现复杂布局的首选方法。

## 13. 解释一下 CSS 中的`box-sizing`属性及其重要性。

**解答**：

`box-sizing`属性用于改变元素的盒模型计算方式。CSS 中的盒模型描述了元素如何生成盒子以及这些盒子如何布局。默认情况下，元素的盒模型由内容（content）、内边距（padding）、边框（border）和外边距（margin）组成。然而，在默认盒模型（`box-sizing: content-box;`）中，元素的宽度和高度仅包括内容的宽度和高度，不包括内边距、边框和外边距。

通过将`box-sizing`属性设置为`border-box`，可以改变这种默认行为。在`border-box`模式下，元素的宽度和高度将包括内容、内边距和边框，但不包括外边距。这种改变对于布局非常有用，因为它允许开发者更容易地控制元素的最终尺寸，而不需要考虑内边距和边框对元素尺寸的影响。

`box-sizing`属性的重要性在于它提供了一种更加直观和可预测的方式来控制元素的尺寸。在响应式设计中，使用`border-box`盒模型可以避免因元素边框和内边距的变化而导致的布局问题。此外，`border-box`模式还简化了布局代码，使得开发者可以更容易地实现复杂的布局效果。

## 14. CSS 中的`position`属性有哪些值？每种值的作用是什么？

**解答**：

CSS 中的`position`属性用于指定一个元素在文档中的定位方式。它主要有以下几个值：

1. **static**：这是元素的默认值。元素按照正常的文档流进行排列，即块级元素会独占一行，行内元素会依次排列。`static`定位的元素不会被`top`、`bottom`、`left`、`right`和`z-index`属性影响。

2. **relative**：元素首先按照正常文档流进行定位，然后通过设置`top`、`bottom`、`left`、`right`属性来调整其位置。相对于它在正常文档流中的位置进行偏移，但不会影响其他元素的位置。

3. **absolute**：元素会从文档流中完全脱离，并相对于其最近的已定位（即`position`不是`static`）祖先元素进行定位。如果没有这样的元素，则相对于初始包含块（通常是视口或`<html>`元素）。`absolute`定位的元素可以设置`top`、`bottom`、`left`、`right`和`z-index`属性。

4. **fixed**：元素会被固定在视口（浏览器窗口）的指定位置，并脱离文档流。即使页面滚动，它也会保持在固定位置。`fixed`定位的元素通常用于创建如固定头部或侧边栏等效果。它也可以使用`top`、`bottom`、`left`、`right`和`z-index`属性进行定位。

5. **sticky**：`sticky`定位是一种特殊的定位方式，它可以说是`relative`和`fixed`定位的混合体。元素首先按照正常文档流进行定位，直到它滚动到某个指定位置（通常是通过`top`、`bottom`、`left`、`right`属性设置）。然后，它就像`fixed`定位的元素一样，固定在指定位置。然而，与`fixed`定位不同，`sticky`定位的元素在达到固定位置之前仍然会保留在文档流中，并占用空间。

## 15. CSS 中的`z-index`属性是如何工作的？它有哪些限制？

**解答**：

`z-index`属性用于控制元素的堆叠顺序。它只能应用于定位元素（即`position`属性不是`static`的元素）。`z-index`的值可以是正数、负数或 0，其中较大的值表示元素将堆叠在较小的值之上。如果两个元素具有相同的`z-index`值，则它们在 HTML 文档中出现的顺序将决定它们的堆叠顺序，后出现的元素将堆叠在先出现的元素之上。

然而，`z-index`属性也有一些限制：

1. **堆叠上下文**：每个堆叠上下文都有自己的`z-index`空间。子元素的`z-index`值只在同一堆叠上下文中有效。如果一个元素创建了新的堆叠上下文（例如，通过`position: relative;`和`z-index`非`auto`），那么其子元素的`z-index`值将仅在该堆叠上下文中有效，并且不会影响到父堆叠上下文或其他堆叠上下文中的元素。

2. **层叠顺序**：在 CSS 中，元素的层叠顺序按照以下规则确定（从下到上）：

   - 背景和边框
   - 负`z-index`值
   - 块级盒的堆叠上下文
   - 浮动盒
   - 内联盒（包括内联块、表格单元格和表格标题）
   - 非定位的后代盒
   - 正`z-index`值
   - 堆叠上下文的层叠顺序由子元素的`z-index`决定

3. **非定位元素**：未定位（`position: static;`）的元素不受`z-index`属性的影响，它们的堆叠顺序由它们在文档流中的位置决定。

4. **跨文档边界**：`z-index`属性不会跨越文档边界（如 iframe 或 frame）工作。每个文档都有自己的堆叠上下文。

## 16. 解释一下 CSS 中的伪类和伪元素，并给出一些常见的例子。

**解答**：

在 CSS 中，伪类和伪元素用于定义元素的特殊状态或创建虚拟的元素。尽管它们名称相似，但它们的用途和语法是不同的。

**伪类（Pseudo-classes）**：

伪类用于定义元素的特殊状态。它们以冒号`:`开头，并用于选择处于特定状态的元素。伪类不创建新的元素或实体，而是对满足特定条件的现有元素应用样式。

- **常见的伪类示例**：
  - `:hover`：用于鼠标悬停在元素上时的样式。
  - `:active`：用于元素被激活（如鼠标点击）时的样式。
  - `:focus`：用于元素获得焦点时的样式（如通过点击或键盘导航）。
  - `:first-child`：用于选择其父元素的第一个子元素。
  - `:nth-child(n)`：用于选择其父元素的第 n 个子元素。
  - `:not(selector)`：用于选择不符合特定选择器的元素。

**伪元素（Pseudo-elements）**：

伪元素用于创建在文档中不存在的虚拟元素，并允许你为这些元素设置样式。它们以双冒号`::`开头（但在一些旧版本的 CSS 中，单冒号`:`也被接受）。

- **常见的伪元素示例**：
  - `::before`：在元素的内容之前插入新的内容或样式，通常与`content`属性结合使用。
  - `::after`：在元素的内容之后插入新的内容或样式，同样与`content`属性结合使用。
  - `::first-letter`：用于选择文本块的第一个字母，并允许你单独对它设置样式。
  - `::first-line`：用于选择文本块的第一行，并允许你单独对它设置样式。
  - `::selection`：用于定义用户选中文本的样式（不是所有浏览器都支持）。

## 17. 解释一下 CSS 中的`transform`属性，并给出一些常见的变换函数。

**解答**：

`transform`属性允许你对元素进行旋转、缩放、倾斜或平移等变换。通过使用这个属性，你可以在不改变文档流的情况下，对元素进行视觉上的变形。`transform`属性可以包含一个或多个变换函数，这些函数通过空格分隔。

**常见的变换函数包括**：

- **translate(x, y)**：沿着 X 轴和 Y 轴移动元素。`translate`函数可以接受长度值或百分比值。
- **rotate(angle)**：将元素围绕其中心点旋转指定的角度。角度可以是度（deg）、弧度（rad）、梯度（grad）或转（turn）。
- **scale(x, y)**：对元素进行缩放。`x`和`y`参数分别定义了元素在水平方向和垂直方向上的缩放比例。如果只提供一个值，则水平和垂直方向上的缩放比例相同。
- **skew(x-angle, y-angle)**：沿着 X 轴和 Y 轴倾斜元素。倾斜会改变元素的形状，但不会移动其位置。
- **matrix(n,n,n,n,n,n)**：提供一个 2D 变换矩阵，允许你进行更复杂的变换，包括旋转、缩放、倾斜和平移的组合。

在 CSS3 中，还引入了`transform-origin`属性，允许你改变元素变换的原点（即旋转或缩放的中心点）。默认情况下，变换的原点是元素的中心点（50% 50%）。但你可以通过修改`transform-origin`属性的值来改变这一点，例如`transform-origin: top left;`会将变换的原点设置为元素的左上角。

## 18. CSS 中的`transition`属性是如何工作的？它能实现哪些效果？

**解答**：

`transition`属性允许 CSS 属性值在一定时间内平滑地过渡变化，而不是立即改变。这可以用于创建动画效果，如元素的颜色、大小、位置等属性的渐变。`transition`属性通常与`:hover`、`:active`等伪类或 JavaScript 一起使用，以实现交互效果。

**`transition`属性的基本语法**：

```css
transition: property duration timing-function delay;
```

- **property**：指定需要过渡的 CSS 属性名称。可以使用逗号分隔多个属性。
- **duration**：过渡效果持续的时间，以秒（s）或毫秒（ms）为单位。
- **timing-function**：指定过渡效果的速度曲线。预定义的值包括`linear`（匀速）、`ease`（先快后慢）、`ease-in`（加速）、`ease-out`（减速）和`ease-in-out`（先加速后减速）。也可以使用`cubic-bezier`函数自定义速度曲线。
- **delay**：过渡效果开始前的延迟时间，以秒（s）或毫秒（ms）为单位。

**`transition`能实现的效果**：

- **平滑的颜色变化**：当鼠标悬停在元素上时，改变其背景色或文本颜色，并通过`transition`实现平滑的过渡效果。
- **元素的渐变移动**：通过改变元素的`margin`、`padding`或`position`属性，并应用`transition`，可以实现元素在页面上的平滑移动。
- **尺寸变化**：当元素被激活或悬停时，改变其宽度、高度或边框大小，并通过`transition`使变化过程更加平滑。
- **组合过渡效果**：可以对多个属性应用`transition`，并通过调整`duration`、`timing-function`和`delay`参数，创建复杂的动画效果。

## 19. 解释一下 CSS 中的`@keyframes`规则，它是如何用于创建动画的？

**解答**：

`@keyframes`规则是 CSS3 中用于创建动画的关键部分。它允许你指定动画在整个过程中不同阶段的关键帧（keyframes），每个关键帧定义了动画中某个时间点的样式。浏览器会自动计算关键帧之间的中间值，从而实现平滑的动画效果。

**`@keyframes`规则的基本语法**：

```css
@keyframes animationName {
  from {
    /* 样式 */
  }
  to {
    /* 样式 */
  }
  /* 或者使用百分比指定多个关键帧 */
  0% {
    /* 样式 */
  }
  50% {
    /* 样式 */
  }
  100% {
    /* 样式 */
  }
}
```

- **animationName**：动画的名称，用于在`animation`属性中引用。
- **from** 和 **to**（或 **0%** 和 **100%**）：定义动画的起始和结束状态。你也可以使用百分比来定义动画过程中的多个关键帧。

**如何使用`@keyframes`创建动画**：

1. 使用`@keyframes`规则定义动画的关键帧。
2. 在需要应用动画的元素上，使用`animation`属性指定动画的名称、持续时间、速度曲线等参数。

例如：

```css
@keyframes example {
  from {
    background-color: red;
  }
  to {
    background-color: yellow;
  }
}

div {
  width: 100px;
  height: 100px;
  background-color: red;
  animation-name: example;
  animation-duration: 4s;
}
```

在这个例子中，`div`元素的背景色会在 4 秒内从红色平滑过渡到黄色。这是通过定义名为`example`的`@keyframes`动画，并在`div`元素上应用这个动画来实现的。
