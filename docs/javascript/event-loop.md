# 事件循环

JavaScript 的事件循环（Event Loop）是 JavaScript 运行时环境（如浏览器和 Node.js）中的一个核心概念，它允许 JavaScript 代码执行非阻塞的 I/O 操作，如用户交互、网络请求等，同时保持应用程序的响应性。了解事件循环对于深入理解 JavaScript 的异步编程模型至关重要。

## 1. 浏览器中的事件循环

在浏览器中，JavaScript 运行在一个称为“事件循环”的单线程环境中。这个单线程负责处理所有的任务，包括执行代码、处理事件、计算以及执行 API 等。虽然只有一个线程用于执行 JavaScript 代码，但浏览器背后可能使用多个线程来处理其他任务，比如渲染 UI、网络请求等。

### 调用栈（Call Stack）

- 调用栈是 JavaScript 引擎用于存储执行上下文（如函数调用）的地方。每当一个函数被调用时，一个新的执行上下文就会被创建并推入调用栈中。
- 当函数执行完成后，它的执行上下文会从栈中弹出，控制权返回给调用者。
- 如果调用栈满了（即达到最大调用深度），就会引发栈溢出错误。

### 堆（Heap）

与栈不同，堆是用来存储对象、数组等复杂数据结构的内存区域。这些数据结构的分配和释放由 JavaScript 引擎的垃圾回收机制自动管理。

### 任务队列（Task Queue）

- 任务队列（也称为宏任务队列）存储了需要异步执行的回调函数。这些回调函数可能来自 I/O 操作（如网络请求、文件读取）、定时器（如 `setTimeout`、`setInterval`）或用户交互（如点击事件）。
- 当调用栈为空时，事件循环会从任务队列中取出一个任务，将其回调函数推入调用栈中执行。

### 微任务队列（Microtask Queue）

- 微任务队列与任务队列类似，但它用于存储需要更高优先级执行的回调函数。这些回调函数通常来源于 Promise 的解决（fulfillment）或拒绝（rejection）、`queueMicrotask` 函数的调用等。
- 在每个宏任务执行完毕后，事件循环会检查微任务队列。如果有微任务存在，它会清空微任务队列中的所有任务，然后再继续执行下一个宏任务。

## 2. 事件循环的工作流程

1. **执行同步代码**：首先，JavaScript 引擎会执行所有的同步代码，直到调用栈为空。
2. **检查微任务队列**：一旦调用栈为空，事件循环会立即检查微任务队列。如果有微任务存在，它会依次执行队列中的所有微任务，直到队列为空。
3. **执行宏任务**：在微任务队列为空后，事件循环会从任务队列中取出一个宏任务执行。这个宏任务的执行会再次进入调用栈，并可能产生新的微任务。
4. **重复上述过程**：这个过程会不断重复，直到任务队列和微任务队列都为空。

## 3. 示例分析

考虑以下代码：

```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
  Promise.resolve().then(() => {
    console.log("3");
  });
}, 0);

Promise.resolve().then(() => {
  console.log("4");
});

console.log("5");
```

执行结果将是：

```
1
5
4
2
3
```

解释：

1. `1` 和 `5` 是同步代码，立即执行。
2. `setTimeout` 回调被放入任务队列。
3. 第一个 `Promise.resolve().then(...)` 的回调被放入微任务队列。
4. 当同步代码执行完毕后，微任务队列中的回调被执行（打印 `4`）。
5. 接着，事件循环从任务队列中取出 `setTimeout` 回调并执行（打印 `2`）。
6. 在 `setTimeout` 回调内部，另一个 `Promise.resolve().then(...)` 的回调被加入微任务队列。
7. 当前宏任务执行完毕后，事件循环再次检查并清空微任务队列（打印 `3`）。

## 4. 结论

JavaScript 的事件循环机制使得异步编程成为可能，同时保证了应用程序的响应性和性能。通过理解事件循环、调用栈、任务队列和微任务队列的工作原理，我们可以更好地编写高效、可维护的异步代码。
