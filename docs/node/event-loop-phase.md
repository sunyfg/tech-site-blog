# Node.js 的事件循环有哪些阶段?

Node.js 的事件循环确实包含多个阶段，每个阶段都有其特定的执行时机和职责。以下是 Node.js 事件循环的主要阶段及其执行时机的详细解释：

## 1. **timers（定时器）阶段**

- **执行时机**：当事件循环进入 timers 阶段时，会检查是否有到期的定时器（`setTimeout`和`setInterval`）。如果有，则执行它们的回调函数。
- **特点**：定时器的回调是按照它们被设定的时间顺序执行的，但实际的执行时间可能会受到系统调度和其他因素的影响。如果设定的时间还未到，则这些回调会等待直到该阶段再次到来。

## 2. **I/O callbacks（I/O 回调）阶段**

- **执行时机**：在 timers 阶段之后，事件循环会进入 I/O callbacks 阶段。这个阶段处理除了`close`回调、`setImmediate`回调和定时器回调之外几乎所有的 I/O 回调。
- **特点**：这些回调通常与 I/O 操作相关，如文件读写、网络通信等。当 I/O 操作完成时，相应的回调函数会被添加到这个阶段的队列中，等待执行。

## 3. **idle, prepare 阶段**

- **执行时机**：这两个阶段主要用于 Node.js 内部使用，通常不需要开发者关心。它们主要用于准备事件循环的后续阶段或处理一些内部状态。
- **特点**：这些阶段的具体执行时机和职责可能会随着 Node.js 版本的更新而有所变化。

## 4. **poll（轮询）阶段**

- **执行时机**：在 I/O callbacks 阶段之后，事件循环会进入 poll 阶段。这个阶段是事件循环中最复杂的阶段之一。
- **特点**：
  - 首先，poll 阶段会检查是否有新的 I/O 事件。如果有，则执行相应的回调函数。
  - 如果没有新的 I/O 事件，但存在`setImmediate`的回调，则 poll 阶段会结束，并进入 check 阶段。
  - 如果既没有新的 I/O 事件，也没有`setImmediate`的回调，但存在到期的定时器，则 poll 阶段会等待直到定时器到期，然后跳过当前阶段，直接进入 timers 阶段。
  - 如果以上条件都不满足，poll 阶段会等待新的 I/O 事件或`setImmediate`的回调。

## 5. **check（检查）阶段**

- **执行时机**：在 poll 阶段之后，如果存在`setImmediate`的回调，则事件循环会进入 check 阶段。
- **特点**：这个阶段专门用于处理`setImmediate`的回调。这些回调会被添加到这个阶段的队列中，并在当前轮询阶段结束后立即执行（但在`close callbacks`阶段之前）。

## 6. **close callbacks（关闭回调）阶段**

- **执行时机**：在 check 阶段之后，如果存在关闭的句柄（如 socket），则事件循环会进入 close callbacks 阶段。
- **特点**：这个阶段用于执行关闭请求的回调，如`socket.on('close', ...)`。这些回调用于处理资源关闭后的清理工作。

## 额外说明

- **nextTick 队列**：`process.nextTick()` 不是一个事件循环的阶段，但它与事件循环紧密相关。`nextTick` 队列中的回调会在当前操作完成后、事件循环的下一个阶段开始前立即执行。这意呀着`nextTick`的回调具有比任何 I/O 事件、定时器或`setImmediate`回调都高的优先级。
- **Promise 回调**：Promise 的解决（resolve）或拒绝（reject）回调通常会在当前微任务队列（microtask queue）中执行。在 Node.js 中，微任务队列通常会在每个事件循环阶段的末尾被清空，但在`nextTick`之后执行。这意味着 Promise 的回调会在`nextTick`回调之后、当前事件循环阶段的其他回调之前执行。

综上所述，Node.js 的事件循环通过这些阶段和机制实现了高效的异步 I/O 操作处理。
