# 生命周期

Vue 的生命周期是指 Vue 实例从创建、初始化、挂载、更新、销毁等一系列过程。在这个过程中，Vue 提供了多个生命周期钩子函数，允许开发者在组件的不同阶段执行自定义逻辑。以下是 Vue 生命周期的详细介绍：

## 生命周期阶段

Vue 的生命周期可以分为以下几个阶段：

1. **创建阶段（Creation）**：

   - **beforeCreate**：在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用，此时数据和方法都还未初始化，无法访问到数据和真实的 DOM。
   - **created**：在实例创建完成后被立即调用。在这一步，实例已完成数据观测、属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。

2. **挂载阶段（Mounting）**：

   - **beforeMount**：在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。此时虚拟 DOM 已经创建完成，但还未挂载到真实 DOM 上，可以在这里更改数据，不会触发 updated 钩子。
   - **mounted**：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当mounted被调用时vm.$el 也在文档内。该钩子在服务器端渲染期间不被调用。此时，组件已经出现在页面中，数据、真实 DOM 都已经处理好了，事件都已经挂载好了，可以在这里操作真实 DOM 等事情。

3. **更新阶段（Updating）**：

   - **beforeUpdate**：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。
   - **updated**：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用这个钩子。当这个钩子被调用时，组件 DOM 已经更新，所以现在可以执行依赖于 DOM 的操作。但要避免更改状态，因为这可能会导致无限更新循环。该钩子在服务器端渲染期间不被调用。

4. **销毁阶段（Destruction）**：
   - **beforeDestroy**：实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。可以在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等。
   - **destroyed**：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

## 其他生命周期钩子

除了上述主要的生命周期钩子外，Vue 还提供了以下用于处理特定场景的生命周期钩子：

- **activated**：被 keep-alive 重活的组件调用，该钩子在服务器端渲染期间不被调用。
- **deactivated**：被 keep-alive 缓存的组件停用时调用，该钩子在服务器端渲染期间不被调用。
- **errorCaptured**：当捕获一个来自子孙组件的错误时被调用，此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播。

## Vue3 生命周期

[官网-组合式 API：生命周期钩子](https://cn.vuejs.org/api/composition-api-lifecycle.html)

Vue 3 中，生命周期钩子的名称有所变化，以更好地与组合式 API（Composition API）保持一致。以下是 Vue 3 中生命周期钩子的对应关系：

- `beforeCreate` -> `setup()`
- `created` -> `setup()`
- `beforeMount` -> `onBeforeMount`
- `mounted` -> `onMounted`
- `beforeUpdate` -> `onBeforeUpdate`
- `updated` -> `onUpdated`
- `beforeDestroy` -> `onBeforeUnmount`
- `destroyed` -> `onUnmounted`
- `errorCaptured` -> `onErrorCaptured`
- `activated` -> `onActivated`
- `deactivated` -> `onDeactivated`

## Vue2 和 Vue3 生命周期对比

`Vue2` 和 `Vue3` 在生命周期方面存在一些显著的区别，这些区别主要体现在生命周期钩子函数的命名、新增的钩子函数、生命周期的触发时机以及合并方式等方面。以下是对这些区别的详细介绍：

### 一、生命周期钩子函数的命名

- **Vue2**：生命周期钩子函数的名称是以`before`和`after`（但 `Vue2` 中并没有使用`after`为前缀的钩子函数，这里主要是与`before`相对应的说明方式）等为前缀的，如`beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`updated`、`beforeDestroy`和`destroyed`。
- **Vue3**：在 `Vue3` 中，这些钩子函数的名称被修改为以`on`为前缀，并添加了一些新的命名方式，如`onBeforeCreate`、`onCreated`、`onBeforeMount`、`onMounted`、`onBeforeUpdate`、`onUpdated`、`onBeforeUnmount`和`onUnmounted`。这种命名方式使得 `Vue3` 的生命周期钩子函数更加统一和易于理解。

### 二、新增的生命周期钩子函数

- **Vue3**引入了一些新的生命周期钩子函数，这些函数在 `Vue2` 中是没有的。例如，`onBeforeMount`和`onBeforeUpdate`等钩子函数，用于在组件挂载和更新之前执行一些操作。此外，`Vue3` 还引入了`onRenderTracked`和`onRenderTriggered`等钩子函数，用于在组件的渲染跟踪和触发器列表中触发，帮助开发者优化渲染性能和执行副作用操作。

### 三、生命周期的触发时机

- **Vue2**：在 `Vue2` 中，组件的生命周期钩子函数是在组件创建、挂载、更新和销毁等不同阶段被依次触发的。这些钩子函数的触发时机是确定的，并且按照特定的顺序执行。
- **Vue3**：在 `Vue3` 中，生命周期的触发时机发生了一些变化。`Vue3` 引入了基于组合 API 的组件写法，使用新的生命周期函数`setup`来配置组件，并且采用了异步更新的机制。这意味着在 `Vue3` 中，组件的创建和更新是异步执行的，生命周期函数的触发时机也可能发生变化。此外，`Vue3` 对生命周期函数的顺序进行了一些调整，以适应新的组件写法和异步更新的机制。

### 四、生命周期的合并方式

- **Vue2**：在 `Vue2` 中，如果一个组件定义了多个钩子函数，那么这些钩子函数会按照特定的顺序依次执行。
- **Vue3**：而在 `Vue3` 中，采用了一种新的生命周期的合并方式，即将相同阶段的钩子函数合并为一个函数。这样可以提高性能并优化组件运行的顺序。同时，`Vue3` 的 `Composition API` 允许开发者将生命周期钩子函数与其他逻辑代码组合在一起，使得组件的逻辑更加清晰和易于维护。

### 五、总结

`Vue3` 与 `Vue2` 在生命周期方面存在明显的区别。`Vue3` 不仅修改了钩子函数的命名方式，新增了一些钩子函数，还改变了生命周期的触发时机和合并方式。这些改变使得 `Vue3` 在性能和开发体验上都有所优化，同时也为开发者带来了一些新的特性和功能。因此，对于正在使用 Vue.js 的开发者来说，了解这些生命周期的区别是很重要的，以便更好地进行项目开发和升级迁移。

## 生命周期图示

![Vue 生命周期图示](../assets/lifecycle_zh-CN.W0MNXI0C.png)

## 总结

Vue 的生命周期提供了丰富的钩子函数，允许开发者在组件的各个阶段执行特定的逻辑。这些钩子函数是 Vue 组件开发中的重要组成部分，合理使用它们可以极大地提高开发效率和组件的灵活性。
